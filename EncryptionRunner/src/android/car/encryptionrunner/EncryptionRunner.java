/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.car.encryptionrunner;

import android.annotation.NonNull;

/**
 * A generalized interface that allows for generating shared secrets as well as encrypting
 * messages.
 */
public interface EncryptionRunner {

    /**
     * Starts an encryption handshake.
     *
     * @return A handshake message with information about the handshake that is started.
     */
    HandshakeMessage initHandshake();

    /**
     * Starts an encryption handshake where the device that is being communicated with already
     * initiated the request.
     *
     * @param initializationRequest the bytes that the other device sent over.
     * @return a handshake message with information about the handshake.
     * @throws HandshakeException if initialization request is invalid.
     */
    HandshakeMessage respondToInitRequest(@NonNull byte[] initializationRequest)
            throws HandshakeException;

    /**
     * Continues a handshake after receiving another response from the connected device.
     *
     * @param response the response from the other device.
     * @return a message that can be used to continue the handshake.
     * @throws HandshakeException if unexpected bytes in response.
     */
    HandshakeMessage continueHandshake(@NonNull byte[] response) throws HandshakeException;

    /**
     * De seriliazes a previously serilized key generated by an instance of this encryption runner.
     *
     * @param serialized the serialized bytes of the key.
     * @return the Key object used for encryption.
     */
    Key keyOf(@NonNull byte[] serialized);

    /**
     * A user visible shared pin. This pin can be used to verify that both devices that are
     * communicating have agreed to the same key and will be shown to a user.
     *
     * @return the user visible pin.
     */
    String getPin();

    /**
     * Encrypts data using an encryption key.
     *
     * @param key  the key used to encrypt the data.
     * @param data the data to be encrypted
     * @return the encrypted data.
     */
    byte[] encryptData(@NonNull Key key, @NonNull byte[] data);

    /**
     * Decrypts data using a specified key.
     *
     * @param key           The key used to decrypt the data.
     * @param encryptedData The encrypted data.
     * @return decrypted data.
     */
    byte[] decryptData(@NonNull Key key, @NonNull byte[] encryptedData);
}
